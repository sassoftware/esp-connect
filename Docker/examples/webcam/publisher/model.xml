<?xml version="1.0"?>
<project pubsub="auto" threads="4" use-tagged-token="true" name="project">
  <mas-modules>
    <mas-module language="python" module="tensorProcess" func-names="preprocess,postprocess">
      <code>
      <![CDATA[
      #! /usr/local/bin/python3.7

import os, sys
import numpy as np

from _modules.input_preproc import PreProcess
import _modules.utils as utils
import _modules.tensor_utils as tensor_utils

args_models_dir = "/mnt/data/onnx/Models"
args_model_metadata = "tiny-yolov2/ModelZoo-tinyyolov2-8.onnx"

model_path = os.path.dirname(args_model_metadata)

#Init Phase
sys.path.append(args_models_dir)
model_metadata = utils.load_module(args_model_metadata)
pre_process = PreProcess(model_metadata.inputs_parameters, model_metadata.onnx_model_type)
decode_module = utils.load_module(os.path.join(model_path, model_metadata.output_decoder))
decode_decoder = decode_module.Decoder(model_metadata.output_decoder_parameters, model_metadata.inputs_parameters)


def preprocess(id, image):
    "Output: id, tensor"

    img_np = tensor_utils.Image2Array(image)

    inference_input = pre_process.process(img_np)

    tensor = tensor_utils.Array2Tensor(inference_input[0])

    return id, tensor


def postprocess(id, tensor_out):
    "Output: id, model_name, model_type, n_objects, coords, coords_type, scores, labels"

    tensor, tensor_dims = tensor_utils.Tensor2Array(tensor_out)
    tensor = tensor.reshape(*tensor_dims)

    tensor_exp = np.expand_dims(tensor, axis=0)

    #shape of original image need to normalize output. not needed for yolov2 and yolov4
    #isvideo = True needed for open pose only if data come form cameras or streaming
    decoded_result =  decode_decoder.decode(tensor_exp, tensor_dims)


    boxes, classes, scores = decoded_result

    if os.environ.get('WRITE_PYTHON_POSTPROC_RESULT', 'false').lower()=="true":
        np.set_printoptions(threshold=sys.maxsize)
        with open('%s/out_tensor_%s.txt' % (os.environ.get('DEMO_HOME', '/Demos-Home'), os.environ.get('TEST_CONFIG', '')), 'w') as f:
            #f.write(str(tensor))
            #f.write(str(tensor_exp))
            f.write("bounding boxes:\n" + str(boxes) + "\n")
            f.write("classes:\n" + str(classes) + "\n")
            f.write("scores:\n" + str(scores) + "\n")

    ret_boxes = []
    for i in range(len(boxes)):
        ret_boxes.extend(boxes[i].tolist())
    ret_label=""
    for j in range(len(classes)):
       ret_label+=model_metadata.output_labels[int(classes[j])] + ","
    ret_scores = np.array(scores).tolist()

    return id, model_metadata.onnx_model, model_metadata.onnx_model_type, len(boxes), ret_boxes, model_metadata.output_coord_type, ret_scores, ret_label
         ]]>
      </code>
    </mas-module>
  </mas-modules>
  <contqueries>
    <contquery name="cq" timing-threshold="5000" trace="w_aggr">
      <windows>
        <window-source name="w_data" index="pi_EMPTY" insert-only="true">
          <schema>
            <fields>
              <field name="id" type="int64" key="true"/>
              <field name="image" type="blob"/>
            </fields>
          </schema>
        </window-source>
        <window-calculate name="w_python1" algorithm="MAS" index="pi_EMPTY" produces-only-inserts="true">
          <schema>
            <fields>
              <field name="id" type="int64" key="true"/>
              <field name="image" type="blob"/>
              <field name="tensor" type="blob"/>

            </fields>
          </schema>
          <mas-map>
            <window-map module="tensorProcess" revision="0" source="w_data" function="preprocess"/>
          </mas-map>
        </window-calculate>

        <window-model-reader name="w_reader" model-type="onnx">
          <parameters>
            <properties>
              <property name="reference">/mnt/data/onnx/Models/tiny-yolov2/ModelZoo-tinyyolov2-8.onnx</property>
              <property name="execProvider">cpu</property>
              <property name="openvinoDeviceType">CPU_FP32</property>
            </properties>
          </parameters>
        </window-model-reader>

        <window-score name="w_score">
          <schema>
            <fields>
              <field name="id" type="int64" key="true"/>
              <field name="image" type="blob"/>
              <field name="tensor_out" type="blob"/>
            </fields>
          </schema>
          <models>
            <offline model-type="onnx">
              <input-map>
                <properties>
                <!-- SAS models and Model Zoo ones has different inputs 
                     this double declaration ensure that both works-->
                  <property name="image">tensor</property>
                  <property name="input1">tensor</property>
                </properties>
              </input-map>
              <output-map>
                <properties>
                <!-- SAS models and Model Zoo ones has different inputs 
                     this double declaration ensure that both works-->                    
                  <property name="grid">tensor_out</property>
                  <property name="convo.9">tensor_out</property>
                </properties>
              </output-map>
            </offline>
          </models>
        </window-score>
        <window-calculate name="w_calc" algorithm="MAS" index="pi_EMPTY">
          <schema>
            <fields>
              <field name="id" type="int64" key="true"/>
              <field name="image" type="blob"/>  
              <field name="model_name" type="string"/>
              <field name="model_type" type="string"/>
              <field name="n_objects" type="double"/>
              <field name="coords" type="array(dbl)"/>
              <field name="coords_type" type="string"/>
              <field name="scores" type="array(dbl)"/>
              <field name="labels" type="string"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="tensorProcess" revision="0" source="w_score" function="postprocess"/>
            </mas-map>
        </window-calculate>
        <window-lua name="w_count" events="create" index="pi_EMPTY">
          <schema>
            <fields>
              <field name="id" type="int64" key="true"/>
              <field name="item" type="string"/>
              <field name="score" type="double"/>
            </fields>
          </schema>
          <use>scores,labels</use>
          <code><![CDATA[
            local   id = 1

            function create(data,context)
                local   events = nil

                if (data.labels ~= nil and data.scores ~= nil)
                then
                    local   i1 = 1
                    local   i2 = 1

                    for s in string.gmatch(data.labels,"([^,]+)")
                    do
                        if (data.scores[i1] ~= nil)
                        then
                            local   e = {}
                            e.id = id
                            e.item = s
                            e.score = data.scores[i1]
                            if (events == nil)
                            then
                                events = {}
                            end
                            events[i2] = e
                            i1 = i1 + 1
                            i2 = i2 + 1
                            id = id + 1
                        end
                    end
                end

                return events
            end
          ]]></code>
        </window-lua>
        <window-copy name="w_copy">
            <retention type="bytime_sliding">60 seconds</retention>
        </window-copy>
        <window-aggregate name="w_aggr">
          <schema>
            <fields>
              <field name="item" type="string" key="true"/>
              <field name="count" type="int32"/>
              <field name="min_score" type="double"/>
              <field name="max_score" type="double"/>
              <field name="avg_score" type="double"/>
            </fields>
          </schema>
          <output>
            <field-expr>ESP_aCount()</field-expr>
            <field-expr>ESP_aMin(score)</field-expr>
            <field-expr>ESP_aMax(score)</field-expr>
            <field-expr>ESP_aAve(score)</field-expr>
          </output>
        </window-aggregate>
      </windows>
      <edges>
        <edge source="w_data" target="w_python1" role="data"/>
        <edge source="w_reader" target="w_score" role="model"/>
        <edge source="w_python1" target="w_score" role="data"/>
        <edge source="w_score" target="w_calc" role="data"/>
        <edge source="w_calc" target="w_count"/>
        <edge source="w_count" target="w_copy"/>
        <edge source="w_copy" target="w_aggr"/>
      </edges>
    </contquery>
  </contqueries>
</project>
